package native

import (
	"encoding/base64"
	"math"
	"math/big"
	"testing"

	"github.com/mr-tron/base58"
	"github.com/nspcc-dev/neo-go/pkg/core/interop"
	"github.com/nspcc-dev/neo-go/pkg/vm"
	"github.com/nspcc-dev/neo-go/pkg/vm/stackitem"
	"github.com/stretchr/testify/require"
)

func TestStdLibItoaAtoi(t *testing.T) {
	s := newStd()
	ic := &interop.Context{VM: vm.New()}
	var actual stackitem.Item

	t.Run("itoa-atoi", func(t *testing.T) {
		var testCases = []struct {
			num    *big.Int
			base   *big.Int
			result string
		}{
			{big.NewInt(0), big.NewInt(10), "0"},
			{big.NewInt(0), big.NewInt(16), "0"},
			{big.NewInt(1), big.NewInt(10), "1"},
			{big.NewInt(-1), big.NewInt(10), "-1"},
			{big.NewInt(1), big.NewInt(16), "1"},
			{big.NewInt(7), big.NewInt(16), "7"},
			{big.NewInt(8), big.NewInt(16), "08"},
			{big.NewInt(65535), big.NewInt(16), "0FFFF"},
			{big.NewInt(15), big.NewInt(16), "0F"},
			{big.NewInt(-1), big.NewInt(16), "F"},
		}

		for _, tc := range testCases {
			require.NotPanics(t, func() {
				actual = s.itoa(ic, []stackitem.Item{stackitem.Make(tc.num), stackitem.Make(tc.base)})
			})
			require.Equal(t, stackitem.Make(tc.result), actual)

			require.NotPanics(t, func() {
				actual = s.atoi(ic, []stackitem.Item{stackitem.Make(tc.result), stackitem.Make(tc.base)})
			})
			require.Equal(t, stackitem.Make(tc.num), actual)
		}

		t.Run("-1", func(t *testing.T) {
			for _, str := range []string{"FF", "FFF", "FFFF"} {
				require.NotPanics(t, func() {
					actual = s.atoi(ic, []stackitem.Item{stackitem.Make(str), stackitem.Make(16)})
				})

				require.Equal(t, stackitem.Make(-1), actual)
			}
		})
	})

	t.Run("itoa error", func(t *testing.T) {
		var testCases = []struct {
			num  *big.Int
			base *big.Int
			err  error
		}{
			{big.NewInt(1), big.NewInt(13), ErrInvalidBase},
			{big.NewInt(-1), new(big.Int).Add(big.NewInt(math.MaxInt64), big.NewInt(10)), ErrInvalidBase},
		}

		for _, tc := range testCases {
			require.PanicsWithError(t, tc.err.Error(), func() {
				_ = s.itoa(ic, []stackitem.Item{stackitem.Make(tc.num), stackitem.Make(tc.base)})
			})
		}
	})

	t.Run("atoi error", func(t *testing.T) {
		var testCases = []struct {
			num  string
			base *big.Int
			err  error
		}{
			{"1", big.NewInt(13), ErrInvalidBase},
			{"1", new(big.Int).Add(big.NewInt(math.MaxInt64), big.NewInt(16)), ErrInvalidBase},
			{"1_000", big.NewInt(10), ErrInvalidFormat},
			{"FE", big.NewInt(10), ErrInvalidFormat},
			{"XD", big.NewInt(16), ErrInvalidFormat},
		}

		for _, tc := range testCases {
			require.PanicsWithError(t, tc.err.Error(), func() {
				_ = s.atoi(ic, []stackitem.Item{stackitem.Make(tc.num), stackitem.Make(tc.base)})
			})
		}
	})
}

func TestStdLibJSON(t *testing.T) {
	s := newStd()
	ic := &interop.Context{VM: vm.New()}
	var actual stackitem.Item

	t.Run("JSONSerialize", func(t *testing.T) {
		t.Run("Good", func(t *testing.T) {
			require.NotPanics(t, func() {
				actual = s.jsonSerialize(ic, []stackitem.Item{stackitem.Make(42)})
			})

			require.Equal(t, stackitem.Make([]byte("42")), actual)
		})

		t.Run("Bad", func(t *testing.T) {
			arr := stackitem.NewArray([]stackitem.Item{
				stackitem.NewByteArray(make([]byte, stackitem.MaxSize/2)),
				stackitem.NewByteArray(make([]byte, stackitem.MaxSize/2)),
			})
			require.Panics(t, func() {
				_ = s.jsonSerialize(ic, []stackitem.Item{arr})
			})
		})
	})

	t.Run("JSONDeserialize", func(t *testing.T) {
		t.Run("Good", func(t *testing.T) {
			require.NotPanics(t, func() {
				actual = s.jsonDeserialize(ic, []stackitem.Item{stackitem.Make("42")})
			})

			require.Equal(t, stackitem.Make(42), actual)
		})
		t.Run("Bad", func(t *testing.T) {
			require.Panics(t, func() {
				_ = s.jsonDeserialize(ic, []stackitem.Item{stackitem.Make("{]")})
			})
			require.Panics(t, func() {
				_ = s.jsonDeserialize(ic, []stackitem.Item{stackitem.NewInterop(nil)})
			})
		})
	})
}

func TestStdLibEncodeDecode(t *testing.T) {
	s := newStd()
	original := []byte("my pretty string")
	encoded64 := base64.StdEncoding.EncodeToString(original)
	encoded58 := base58.Encode(original)
	ic := &interop.Context{VM: vm.New()}
	var actual stackitem.Item

	t.Run("Encode64", func(t *testing.T) {
		require.NotPanics(t, func() {
			actual = s.base64Encode(ic, []stackitem.Item{stackitem.Make(original)})
		})
		require.Equal(t, stackitem.Make(encoded64), actual)
	})
	t.Run("Encode58", func(t *testing.T) {
		require.NotPanics(t, func() {
			actual = s.base58Encode(ic, []stackitem.Item{stackitem.Make(original)})
		})
		require.Equal(t, stackitem.Make(encoded58), actual)
	})
	t.Run("Decode64/positive", func(t *testing.T) {
		require.NotPanics(t, func() {
			actual = s.base64Decode(ic, []stackitem.Item{stackitem.Make(encoded64)})
		})
		require.Equal(t, stackitem.Make(original), actual)
	})
	t.Run("Decode64/error", func(t *testing.T) {
		require.Panics(t, func() {
			_ = s.base64Decode(ic, []stackitem.Item{stackitem.Make(encoded64 + "%")})
		})
		require.Panics(t, func() {
			_ = s.base64Decode(ic, []stackitem.Item{stackitem.NewInterop(nil)})
		})
	})
	t.Run("Decode58/positive", func(t *testing.T) {
		require.NotPanics(t, func() {
			actual = s.base58Decode(ic, []stackitem.Item{stackitem.Make(encoded58)})
		})
		require.Equal(t, stackitem.Make(original), actual)
	})
	t.Run("Decode58/error", func(t *testing.T) {
		require.Panics(t, func() {
			_ = s.base58Decode(ic, []stackitem.Item{stackitem.Make(encoded58 + "%")})
		})
		require.Panics(t, func() {
			_ = s.base58Decode(ic, []stackitem.Item{stackitem.NewInterop(nil)})
		})
	})
}
